# 静态库和共享库的区别  
根据链接时期不同，库分为静态库和动态库。静态库是在程序编译时链接的，动态库是在程序运行时链接的。  
库是预先编译好的方法的集合 ，linux上库的命名一般为libxxx.a(静态库)libxxx.so(动态库)，库文件常存放的地点为/lib或/usr/lib，库对应的头文件一般存放在/usr/include中  
下面介绍两种库：  
## 1.静态库的生成  
若有两种方法int add(int a,int b),int max(int a,int b)分别在两个文件add.c和max.c中存放，则静态库的生成过程如下  
1）：将所有的.c文件编译成.o目标文件  
gcc -c add.c      生成add.o  
gcc -c max.c      生成max.o  
2）：对生成的.o目标文件打包生成静态库  
ar crv libfoo.a add.o max.o          //libfoo.a是库的名字  
ar:做库的命令  
c:创建库  
r:将方法添加到库里  
v：显示过程，可以不要  
3）：使用静态库    
gcc -o main main.c -L. -lfoo       //这里写的foo是去掉前缀后缀后的名字  
-L：指定路径 .代表当前路径  
-l：指定库名  
![](images/artiles-01.png)
## 2.共享库的生成  
1）将所有的.c文件编译成.o目标文件  
gcc -c max.c  
gcc -c add.c  
2) 对生成的.o文件处理生成共享库，假设共享库的名字为libfoo.so  
gcc -shared -fPIC -o libfoo.so add.o max.o  
参数-shared 表示输出结果是共享库类型的  
-fPIC 表示使用地址无关代码（Position Independent Code）技术来生产输出文件  
3）库的使用  
cc -o main main.c -lfoo  
cp  libfoo.so  /usr/lib  
![](images/artiles-02.png)
## 3.总结  
链接静态库其实从某种意义上来说也是一种粘贴复制，只不过它操作的对象是目标代码而不是源码而已。因为静态库被链接后库就直接嵌入可执行文件中了，这样就带来了两个问题。  
首先就是系统空间被浪费了。这是显而易见的，想象一下，如果多个程序链接了同一个库，则每一个生成的可执行文件就都会有一个库的副本，必然会浪费系统空间。  
一旦发现了库中有bug，挽救起来就比较麻烦了。必须一一把链接该库的程序找出来，然后重新编译。  
而动态库的出现正弥补了静态库的以上弊端。因为动态库是在程序运行时被链接的，所以磁盘上只须保留一份副本，因此节约了磁盘空间。如果发现了bug或要升级也很简单，只要用新的库把原来的替换掉就行了。  
>那么，是不是静态库就一无是处了呢？  
答：非也非也。想象一下这样的情况：如果你用libpcap库编了一个程序，要给被人运行，而他的系统上没有装pcap库，该怎么解决呢？最简单的办法就是编译该程序时把所有要链接的库都链接它们的静态库，这样，就可以在别人的系统上直接运行该程序了。  

正因为动态库在程序运行时被链接，故程序的运行速度和链接静态库的版本相比必然会打折扣。然而瑕不掩瑜，动态库的不足相对于它带来的好处在现今硬件下简直是微不足道的，所以链接程序在链接时一般是优先链接动态库的，除非用-static参数指定链接静态库。  
